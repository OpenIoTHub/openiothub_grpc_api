// Code generated by protoc-gen-go-grpc. DO NOT EDIT.
// versions:
// - protoc-gen-go-grpc v1.5.1
// - protoc             v5.29.3
// source: proto/mobile/mobile.proto

package pb

import (
	context "context"
	grpc "google.golang.org/grpc"
	codes "google.golang.org/grpc/codes"
	status "google.golang.org/grpc/status"
	emptypb "google.golang.org/protobuf/types/known/emptypb"
	wrapperspb "google.golang.org/protobuf/types/known/wrapperspb"
)

// This is a compile-time assertion to ensure that this generated file
// is compatible with the grpc package it is being compiled against.
// Requires gRPC-Go v1.64.0 or later.
const _ = grpc.SupportPackageIsVersion9

const (
	SessionManager_CreateOneSession_FullMethodName             = "/pb.SessionManager/CreateOneSession"
	SessionManager_DeleteOneSession_FullMethodName             = "/pb.SessionManager/DeleteOneSession"
	SessionManager_GetOneSession_FullMethodName                = "/pb.SessionManager/GetOneSession"
	SessionManager_GetAllSession_FullMethodName                = "/pb.SessionManager/GetAllSession"
	SessionManager_UpdateSessionNameDescription_FullMethodName = "/pb.SessionManager/UpdateSessionNameDescription"
	SessionManager_CreateOneSOCKS5_FullMethodName              = "/pb.SessionManager/CreateOneSOCKS5"
	SessionManager_DeleteOneSOCKS5_FullMethodName              = "/pb.SessionManager/DeleteOneSOCKS5"
	SessionManager_GetOneSOCKS5_FullMethodName                 = "/pb.SessionManager/GetOneSOCKS5"
	SessionManager_RefreshmDNSProxyList_FullMethodName         = "/pb.SessionManager/RefreshmDNSProxyList"
	SessionManager_CreateTcpProxyList_FullMethodName           = "/pb.SessionManager/CreateTcpProxyList"
	SessionManager_GetAllTCP_FullMethodName                    = "/pb.SessionManager/GetAllTCP"
	SessionManager_DeleteRemoteGatewayConfig_FullMethodName    = "/pb.SessionManager/DeleteRemoteGatewayConfig"
)

// SessionManagerClient is the client API for SessionManager service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://pkg.go.dev/google.golang.org/grpc/?tab=doc#ClientConn.NewStream.
//
// 服务的定义
type SessionManagerClient interface {
	// Sends a greeting
	CreateOneSession(ctx context.Context, in *SessionConfig, opts ...grpc.CallOption) (*SessionConfig, error)
	DeleteOneSession(ctx context.Context, in *SessionConfig, opts ...grpc.CallOption) (*emptypb.Empty, error)
	GetOneSession(ctx context.Context, in *SessionConfig, opts ...grpc.CallOption) (*SessionConfig, error)
	GetAllSession(ctx context.Context, in *emptypb.Empty, opts ...grpc.CallOption) (*SessionList, error)
	UpdateSessionNameDescription(ctx context.Context, in *SessionConfig, opts ...grpc.CallOption) (*SessionConfig, error)
	// Socks5
	CreateOneSOCKS5(ctx context.Context, in *SOCKS5Config, opts ...grpc.CallOption) (*SOCKS5Config, error)
	DeleteOneSOCKS5(ctx context.Context, in *SOCKS5Config, opts ...grpc.CallOption) (*emptypb.Empty, error)
	GetOneSOCKS5(ctx context.Context, in *SOCKS5Config, opts ...grpc.CallOption) (*SOCKS5Config, error)
	// :TODO  获取所有的设备列表
	// mDNS刷新列表
	RefreshmDNSProxyList(ctx context.Context, in *SessionConfig, opts ...grpc.CallOption) (*emptypb.Empty, error)
	CreateTcpProxyList(ctx context.Context, in *PortList, opts ...grpc.CallOption) (*emptypb.Empty, error)
	// 获取通过mDNS自动映射的TCP端口列表，然后可以查看页面
	GetAllTCP(ctx context.Context, in *SessionConfig, opts ...grpc.CallOption) (*PortList, error)
	// :TODO VPN接口
	// 通知这个网关删除配置文件中的token
	DeleteRemoteGatewayConfig(ctx context.Context, in *SessionConfig, opts ...grpc.CallOption) (*OpenIoTHubOperationResponse, error)
}

type sessionManagerClient struct {
	cc grpc.ClientConnInterface
}

func NewSessionManagerClient(cc grpc.ClientConnInterface) SessionManagerClient {
	return &sessionManagerClient{cc}
}

func (c *sessionManagerClient) CreateOneSession(ctx context.Context, in *SessionConfig, opts ...grpc.CallOption) (*SessionConfig, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(SessionConfig)
	err := c.cc.Invoke(ctx, SessionManager_CreateOneSession_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *sessionManagerClient) DeleteOneSession(ctx context.Context, in *SessionConfig, opts ...grpc.CallOption) (*emptypb.Empty, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(emptypb.Empty)
	err := c.cc.Invoke(ctx, SessionManager_DeleteOneSession_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *sessionManagerClient) GetOneSession(ctx context.Context, in *SessionConfig, opts ...grpc.CallOption) (*SessionConfig, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(SessionConfig)
	err := c.cc.Invoke(ctx, SessionManager_GetOneSession_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *sessionManagerClient) GetAllSession(ctx context.Context, in *emptypb.Empty, opts ...grpc.CallOption) (*SessionList, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(SessionList)
	err := c.cc.Invoke(ctx, SessionManager_GetAllSession_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *sessionManagerClient) UpdateSessionNameDescription(ctx context.Context, in *SessionConfig, opts ...grpc.CallOption) (*SessionConfig, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(SessionConfig)
	err := c.cc.Invoke(ctx, SessionManager_UpdateSessionNameDescription_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *sessionManagerClient) CreateOneSOCKS5(ctx context.Context, in *SOCKS5Config, opts ...grpc.CallOption) (*SOCKS5Config, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(SOCKS5Config)
	err := c.cc.Invoke(ctx, SessionManager_CreateOneSOCKS5_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *sessionManagerClient) DeleteOneSOCKS5(ctx context.Context, in *SOCKS5Config, opts ...grpc.CallOption) (*emptypb.Empty, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(emptypb.Empty)
	err := c.cc.Invoke(ctx, SessionManager_DeleteOneSOCKS5_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *sessionManagerClient) GetOneSOCKS5(ctx context.Context, in *SOCKS5Config, opts ...grpc.CallOption) (*SOCKS5Config, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(SOCKS5Config)
	err := c.cc.Invoke(ctx, SessionManager_GetOneSOCKS5_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *sessionManagerClient) RefreshmDNSProxyList(ctx context.Context, in *SessionConfig, opts ...grpc.CallOption) (*emptypb.Empty, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(emptypb.Empty)
	err := c.cc.Invoke(ctx, SessionManager_RefreshmDNSProxyList_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *sessionManagerClient) CreateTcpProxyList(ctx context.Context, in *PortList, opts ...grpc.CallOption) (*emptypb.Empty, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(emptypb.Empty)
	err := c.cc.Invoke(ctx, SessionManager_CreateTcpProxyList_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *sessionManagerClient) GetAllTCP(ctx context.Context, in *SessionConfig, opts ...grpc.CallOption) (*PortList, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(PortList)
	err := c.cc.Invoke(ctx, SessionManager_GetAllTCP_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *sessionManagerClient) DeleteRemoteGatewayConfig(ctx context.Context, in *SessionConfig, opts ...grpc.CallOption) (*OpenIoTHubOperationResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(OpenIoTHubOperationResponse)
	err := c.cc.Invoke(ctx, SessionManager_DeleteRemoteGatewayConfig_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// SessionManagerServer is the server API for SessionManager service.
// All implementations must embed UnimplementedSessionManagerServer
// for forward compatibility.
//
// 服务的定义
type SessionManagerServer interface {
	// Sends a greeting
	CreateOneSession(context.Context, *SessionConfig) (*SessionConfig, error)
	DeleteOneSession(context.Context, *SessionConfig) (*emptypb.Empty, error)
	GetOneSession(context.Context, *SessionConfig) (*SessionConfig, error)
	GetAllSession(context.Context, *emptypb.Empty) (*SessionList, error)
	UpdateSessionNameDescription(context.Context, *SessionConfig) (*SessionConfig, error)
	// Socks5
	CreateOneSOCKS5(context.Context, *SOCKS5Config) (*SOCKS5Config, error)
	DeleteOneSOCKS5(context.Context, *SOCKS5Config) (*emptypb.Empty, error)
	GetOneSOCKS5(context.Context, *SOCKS5Config) (*SOCKS5Config, error)
	// :TODO  获取所有的设备列表
	// mDNS刷新列表
	RefreshmDNSProxyList(context.Context, *SessionConfig) (*emptypb.Empty, error)
	CreateTcpProxyList(context.Context, *PortList) (*emptypb.Empty, error)
	// 获取通过mDNS自动映射的TCP端口列表，然后可以查看页面
	GetAllTCP(context.Context, *SessionConfig) (*PortList, error)
	// :TODO VPN接口
	// 通知这个网关删除配置文件中的token
	DeleteRemoteGatewayConfig(context.Context, *SessionConfig) (*OpenIoTHubOperationResponse, error)
	mustEmbedUnimplementedSessionManagerServer()
}

// UnimplementedSessionManagerServer must be embedded to have
// forward compatible implementations.
//
// NOTE: this should be embedded by value instead of pointer to avoid a nil
// pointer dereference when methods are called.
type UnimplementedSessionManagerServer struct{}

func (UnimplementedSessionManagerServer) CreateOneSession(context.Context, *SessionConfig) (*SessionConfig, error) {
	return nil, status.Errorf(codes.Unimplemented, "method CreateOneSession not implemented")
}
func (UnimplementedSessionManagerServer) DeleteOneSession(context.Context, *SessionConfig) (*emptypb.Empty, error) {
	return nil, status.Errorf(codes.Unimplemented, "method DeleteOneSession not implemented")
}
func (UnimplementedSessionManagerServer) GetOneSession(context.Context, *SessionConfig) (*SessionConfig, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetOneSession not implemented")
}
func (UnimplementedSessionManagerServer) GetAllSession(context.Context, *emptypb.Empty) (*SessionList, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetAllSession not implemented")
}
func (UnimplementedSessionManagerServer) UpdateSessionNameDescription(context.Context, *SessionConfig) (*SessionConfig, error) {
	return nil, status.Errorf(codes.Unimplemented, "method UpdateSessionNameDescription not implemented")
}
func (UnimplementedSessionManagerServer) CreateOneSOCKS5(context.Context, *SOCKS5Config) (*SOCKS5Config, error) {
	return nil, status.Errorf(codes.Unimplemented, "method CreateOneSOCKS5 not implemented")
}
func (UnimplementedSessionManagerServer) DeleteOneSOCKS5(context.Context, *SOCKS5Config) (*emptypb.Empty, error) {
	return nil, status.Errorf(codes.Unimplemented, "method DeleteOneSOCKS5 not implemented")
}
func (UnimplementedSessionManagerServer) GetOneSOCKS5(context.Context, *SOCKS5Config) (*SOCKS5Config, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetOneSOCKS5 not implemented")
}
func (UnimplementedSessionManagerServer) RefreshmDNSProxyList(context.Context, *SessionConfig) (*emptypb.Empty, error) {
	return nil, status.Errorf(codes.Unimplemented, "method RefreshmDNSProxyList not implemented")
}
func (UnimplementedSessionManagerServer) CreateTcpProxyList(context.Context, *PortList) (*emptypb.Empty, error) {
	return nil, status.Errorf(codes.Unimplemented, "method CreateTcpProxyList not implemented")
}
func (UnimplementedSessionManagerServer) GetAllTCP(context.Context, *SessionConfig) (*PortList, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetAllTCP not implemented")
}
func (UnimplementedSessionManagerServer) DeleteRemoteGatewayConfig(context.Context, *SessionConfig) (*OpenIoTHubOperationResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method DeleteRemoteGatewayConfig not implemented")
}
func (UnimplementedSessionManagerServer) mustEmbedUnimplementedSessionManagerServer() {}
func (UnimplementedSessionManagerServer) testEmbeddedByValue()                        {}

// UnsafeSessionManagerServer may be embedded to opt out of forward compatibility for this service.
// Use of this interface is not recommended, as added methods to SessionManagerServer will
// result in compilation errors.
type UnsafeSessionManagerServer interface {
	mustEmbedUnimplementedSessionManagerServer()
}

func RegisterSessionManagerServer(s grpc.ServiceRegistrar, srv SessionManagerServer) {
	// If the following call pancis, it indicates UnimplementedSessionManagerServer was
	// embedded by pointer and is nil.  This will cause panics if an
	// unimplemented method is ever invoked, so we test this at initialization
	// time to prevent it from happening at runtime later due to I/O.
	if t, ok := srv.(interface{ testEmbeddedByValue() }); ok {
		t.testEmbeddedByValue()
	}
	s.RegisterService(&SessionManager_ServiceDesc, srv)
}

func _SessionManager_CreateOneSession_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(SessionConfig)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(SessionManagerServer).CreateOneSession(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: SessionManager_CreateOneSession_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(SessionManagerServer).CreateOneSession(ctx, req.(*SessionConfig))
	}
	return interceptor(ctx, in, info, handler)
}

func _SessionManager_DeleteOneSession_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(SessionConfig)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(SessionManagerServer).DeleteOneSession(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: SessionManager_DeleteOneSession_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(SessionManagerServer).DeleteOneSession(ctx, req.(*SessionConfig))
	}
	return interceptor(ctx, in, info, handler)
}

func _SessionManager_GetOneSession_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(SessionConfig)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(SessionManagerServer).GetOneSession(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: SessionManager_GetOneSession_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(SessionManagerServer).GetOneSession(ctx, req.(*SessionConfig))
	}
	return interceptor(ctx, in, info, handler)
}

func _SessionManager_GetAllSession_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(emptypb.Empty)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(SessionManagerServer).GetAllSession(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: SessionManager_GetAllSession_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(SessionManagerServer).GetAllSession(ctx, req.(*emptypb.Empty))
	}
	return interceptor(ctx, in, info, handler)
}

func _SessionManager_UpdateSessionNameDescription_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(SessionConfig)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(SessionManagerServer).UpdateSessionNameDescription(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: SessionManager_UpdateSessionNameDescription_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(SessionManagerServer).UpdateSessionNameDescription(ctx, req.(*SessionConfig))
	}
	return interceptor(ctx, in, info, handler)
}

func _SessionManager_CreateOneSOCKS5_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(SOCKS5Config)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(SessionManagerServer).CreateOneSOCKS5(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: SessionManager_CreateOneSOCKS5_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(SessionManagerServer).CreateOneSOCKS5(ctx, req.(*SOCKS5Config))
	}
	return interceptor(ctx, in, info, handler)
}

func _SessionManager_DeleteOneSOCKS5_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(SOCKS5Config)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(SessionManagerServer).DeleteOneSOCKS5(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: SessionManager_DeleteOneSOCKS5_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(SessionManagerServer).DeleteOneSOCKS5(ctx, req.(*SOCKS5Config))
	}
	return interceptor(ctx, in, info, handler)
}

func _SessionManager_GetOneSOCKS5_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(SOCKS5Config)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(SessionManagerServer).GetOneSOCKS5(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: SessionManager_GetOneSOCKS5_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(SessionManagerServer).GetOneSOCKS5(ctx, req.(*SOCKS5Config))
	}
	return interceptor(ctx, in, info, handler)
}

func _SessionManager_RefreshmDNSProxyList_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(SessionConfig)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(SessionManagerServer).RefreshmDNSProxyList(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: SessionManager_RefreshmDNSProxyList_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(SessionManagerServer).RefreshmDNSProxyList(ctx, req.(*SessionConfig))
	}
	return interceptor(ctx, in, info, handler)
}

func _SessionManager_CreateTcpProxyList_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(PortList)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(SessionManagerServer).CreateTcpProxyList(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: SessionManager_CreateTcpProxyList_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(SessionManagerServer).CreateTcpProxyList(ctx, req.(*PortList))
	}
	return interceptor(ctx, in, info, handler)
}

func _SessionManager_GetAllTCP_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(SessionConfig)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(SessionManagerServer).GetAllTCP(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: SessionManager_GetAllTCP_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(SessionManagerServer).GetAllTCP(ctx, req.(*SessionConfig))
	}
	return interceptor(ctx, in, info, handler)
}

func _SessionManager_DeleteRemoteGatewayConfig_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(SessionConfig)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(SessionManagerServer).DeleteRemoteGatewayConfig(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: SessionManager_DeleteRemoteGatewayConfig_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(SessionManagerServer).DeleteRemoteGatewayConfig(ctx, req.(*SessionConfig))
	}
	return interceptor(ctx, in, info, handler)
}

// SessionManager_ServiceDesc is the grpc.ServiceDesc for SessionManager service.
// It's only intended for direct use with grpc.RegisterService,
// and not to be introspected or modified (even as a copy)
var SessionManager_ServiceDesc = grpc.ServiceDesc{
	ServiceName: "pb.SessionManager",
	HandlerType: (*SessionManagerServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "CreateOneSession",
			Handler:    _SessionManager_CreateOneSession_Handler,
		},
		{
			MethodName: "DeleteOneSession",
			Handler:    _SessionManager_DeleteOneSession_Handler,
		},
		{
			MethodName: "GetOneSession",
			Handler:    _SessionManager_GetOneSession_Handler,
		},
		{
			MethodName: "GetAllSession",
			Handler:    _SessionManager_GetAllSession_Handler,
		},
		{
			MethodName: "UpdateSessionNameDescription",
			Handler:    _SessionManager_UpdateSessionNameDescription_Handler,
		},
		{
			MethodName: "CreateOneSOCKS5",
			Handler:    _SessionManager_CreateOneSOCKS5_Handler,
		},
		{
			MethodName: "DeleteOneSOCKS5",
			Handler:    _SessionManager_DeleteOneSOCKS5_Handler,
		},
		{
			MethodName: "GetOneSOCKS5",
			Handler:    _SessionManager_GetOneSOCKS5_Handler,
		},
		{
			MethodName: "RefreshmDNSProxyList",
			Handler:    _SessionManager_RefreshmDNSProxyList_Handler,
		},
		{
			MethodName: "CreateTcpProxyList",
			Handler:    _SessionManager_CreateTcpProxyList_Handler,
		},
		{
			MethodName: "GetAllTCP",
			Handler:    _SessionManager_GetAllTCP_Handler,
		},
		{
			MethodName: "DeleteRemoteGatewayConfig",
			Handler:    _SessionManager_DeleteRemoteGatewayConfig_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "proto/mobile/mobile.proto",
}

const (
	CommonDeviceManager_AddDevice_FullMethodName    = "/pb.CommonDeviceManager/AddDevice"
	CommonDeviceManager_DelDevice_FullMethodName    = "/pb.CommonDeviceManager/DelDevice"
	CommonDeviceManager_GetAllDevice_FullMethodName = "/pb.CommonDeviceManager/GetAllDevice"
	CommonDeviceManager_SetDeviceMac_FullMethodName = "/pb.CommonDeviceManager/SetDeviceMac"
	CommonDeviceManager_WakeOnLAN_FullMethodName    = "/pb.CommonDeviceManager/WakeOnLAN"
	CommonDeviceManager_CreateOneTCP_FullMethodName = "/pb.CommonDeviceManager/CreateOneTCP"
	CommonDeviceManager_DeleteOneTCP_FullMethodName = "/pb.CommonDeviceManager/DeleteOneTCP"
	CommonDeviceManager_GetOneTCP_FullMethodName    = "/pb.CommonDeviceManager/GetOneTCP"
	CommonDeviceManager_GetAllTCP_FullMethodName    = "/pb.CommonDeviceManager/GetAllTCP"
	CommonDeviceManager_CreateOneUDP_FullMethodName = "/pb.CommonDeviceManager/CreateOneUDP"
	CommonDeviceManager_DeleteOneUDP_FullMethodName = "/pb.CommonDeviceManager/DeleteOneUDP"
	CommonDeviceManager_GetOneUDP_FullMethodName    = "/pb.CommonDeviceManager/GetOneUDP"
	CommonDeviceManager_GetAllUDP_FullMethodName    = "/pb.CommonDeviceManager/GetAllUDP"
	CommonDeviceManager_CreateOneFTP_FullMethodName = "/pb.CommonDeviceManager/CreateOneFTP"
	CommonDeviceManager_DeleteOneFTP_FullMethodName = "/pb.CommonDeviceManager/DeleteOneFTP"
	CommonDeviceManager_GetOneFTP_FullMethodName    = "/pb.CommonDeviceManager/GetOneFTP"
	CommonDeviceManager_GetAllFTP_FullMethodName    = "/pb.CommonDeviceManager/GetAllFTP"
)

// CommonDeviceManagerClient is the client API for CommonDeviceManager service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://pkg.go.dev/google.golang.org/grpc/?tab=doc#ClientConn.NewStream.
//
// 服务的定义
type CommonDeviceManagerClient interface {
	// 设备的操作:增删
	AddDevice(ctx context.Context, in *Device, opts ...grpc.CallOption) (*emptypb.Empty, error)
	DelDevice(ctx context.Context, in *Device, opts ...grpc.CallOption) (*emptypb.Empty, error)
	GetAllDevice(ctx context.Context, in *emptypb.Empty, opts ...grpc.CallOption) (*DeviceList, error)
	// 网络唤醒
	SetDeviceMac(ctx context.Context, in *Device, opts ...grpc.CallOption) (*emptypb.Empty, error)
	WakeOnLAN(ctx context.Context, in *Device, opts ...grpc.CallOption) (*emptypb.Empty, error)
	// TCP
	CreateOneTCP(ctx context.Context, in *PortConfig, opts ...grpc.CallOption) (*PortConfig, error)
	DeleteOneTCP(ctx context.Context, in *PortConfig, opts ...grpc.CallOption) (*emptypb.Empty, error)
	GetOneTCP(ctx context.Context, in *PortConfig, opts ...grpc.CallOption) (*PortConfig, error)
	GetAllTCP(ctx context.Context, in *Device, opts ...grpc.CallOption) (*PortList, error)
	// UDP
	CreateOneUDP(ctx context.Context, in *PortConfig, opts ...grpc.CallOption) (*PortConfig, error)
	DeleteOneUDP(ctx context.Context, in *PortConfig, opts ...grpc.CallOption) (*emptypb.Empty, error)
	GetOneUDP(ctx context.Context, in *PortConfig, opts ...grpc.CallOption) (*PortConfig, error)
	GetAllUDP(ctx context.Context, in *Device, opts ...grpc.CallOption) (*PortList, error)
	// FTP
	CreateOneFTP(ctx context.Context, in *PortConfig, opts ...grpc.CallOption) (*PortConfig, error)
	DeleteOneFTP(ctx context.Context, in *PortConfig, opts ...grpc.CallOption) (*emptypb.Empty, error)
	GetOneFTP(ctx context.Context, in *PortConfig, opts ...grpc.CallOption) (*PortConfig, error)
	GetAllFTP(ctx context.Context, in *Device, opts ...grpc.CallOption) (*PortList, error)
}

type commonDeviceManagerClient struct {
	cc grpc.ClientConnInterface
}

func NewCommonDeviceManagerClient(cc grpc.ClientConnInterface) CommonDeviceManagerClient {
	return &commonDeviceManagerClient{cc}
}

func (c *commonDeviceManagerClient) AddDevice(ctx context.Context, in *Device, opts ...grpc.CallOption) (*emptypb.Empty, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(emptypb.Empty)
	err := c.cc.Invoke(ctx, CommonDeviceManager_AddDevice_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *commonDeviceManagerClient) DelDevice(ctx context.Context, in *Device, opts ...grpc.CallOption) (*emptypb.Empty, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(emptypb.Empty)
	err := c.cc.Invoke(ctx, CommonDeviceManager_DelDevice_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *commonDeviceManagerClient) GetAllDevice(ctx context.Context, in *emptypb.Empty, opts ...grpc.CallOption) (*DeviceList, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(DeviceList)
	err := c.cc.Invoke(ctx, CommonDeviceManager_GetAllDevice_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *commonDeviceManagerClient) SetDeviceMac(ctx context.Context, in *Device, opts ...grpc.CallOption) (*emptypb.Empty, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(emptypb.Empty)
	err := c.cc.Invoke(ctx, CommonDeviceManager_SetDeviceMac_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *commonDeviceManagerClient) WakeOnLAN(ctx context.Context, in *Device, opts ...grpc.CallOption) (*emptypb.Empty, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(emptypb.Empty)
	err := c.cc.Invoke(ctx, CommonDeviceManager_WakeOnLAN_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *commonDeviceManagerClient) CreateOneTCP(ctx context.Context, in *PortConfig, opts ...grpc.CallOption) (*PortConfig, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(PortConfig)
	err := c.cc.Invoke(ctx, CommonDeviceManager_CreateOneTCP_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *commonDeviceManagerClient) DeleteOneTCP(ctx context.Context, in *PortConfig, opts ...grpc.CallOption) (*emptypb.Empty, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(emptypb.Empty)
	err := c.cc.Invoke(ctx, CommonDeviceManager_DeleteOneTCP_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *commonDeviceManagerClient) GetOneTCP(ctx context.Context, in *PortConfig, opts ...grpc.CallOption) (*PortConfig, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(PortConfig)
	err := c.cc.Invoke(ctx, CommonDeviceManager_GetOneTCP_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *commonDeviceManagerClient) GetAllTCP(ctx context.Context, in *Device, opts ...grpc.CallOption) (*PortList, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(PortList)
	err := c.cc.Invoke(ctx, CommonDeviceManager_GetAllTCP_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *commonDeviceManagerClient) CreateOneUDP(ctx context.Context, in *PortConfig, opts ...grpc.CallOption) (*PortConfig, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(PortConfig)
	err := c.cc.Invoke(ctx, CommonDeviceManager_CreateOneUDP_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *commonDeviceManagerClient) DeleteOneUDP(ctx context.Context, in *PortConfig, opts ...grpc.CallOption) (*emptypb.Empty, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(emptypb.Empty)
	err := c.cc.Invoke(ctx, CommonDeviceManager_DeleteOneUDP_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *commonDeviceManagerClient) GetOneUDP(ctx context.Context, in *PortConfig, opts ...grpc.CallOption) (*PortConfig, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(PortConfig)
	err := c.cc.Invoke(ctx, CommonDeviceManager_GetOneUDP_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *commonDeviceManagerClient) GetAllUDP(ctx context.Context, in *Device, opts ...grpc.CallOption) (*PortList, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(PortList)
	err := c.cc.Invoke(ctx, CommonDeviceManager_GetAllUDP_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *commonDeviceManagerClient) CreateOneFTP(ctx context.Context, in *PortConfig, opts ...grpc.CallOption) (*PortConfig, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(PortConfig)
	err := c.cc.Invoke(ctx, CommonDeviceManager_CreateOneFTP_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *commonDeviceManagerClient) DeleteOneFTP(ctx context.Context, in *PortConfig, opts ...grpc.CallOption) (*emptypb.Empty, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(emptypb.Empty)
	err := c.cc.Invoke(ctx, CommonDeviceManager_DeleteOneFTP_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *commonDeviceManagerClient) GetOneFTP(ctx context.Context, in *PortConfig, opts ...grpc.CallOption) (*PortConfig, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(PortConfig)
	err := c.cc.Invoke(ctx, CommonDeviceManager_GetOneFTP_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *commonDeviceManagerClient) GetAllFTP(ctx context.Context, in *Device, opts ...grpc.CallOption) (*PortList, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(PortList)
	err := c.cc.Invoke(ctx, CommonDeviceManager_GetAllFTP_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// CommonDeviceManagerServer is the server API for CommonDeviceManager service.
// All implementations must embed UnimplementedCommonDeviceManagerServer
// for forward compatibility.
//
// 服务的定义
type CommonDeviceManagerServer interface {
	// 设备的操作:增删
	AddDevice(context.Context, *Device) (*emptypb.Empty, error)
	DelDevice(context.Context, *Device) (*emptypb.Empty, error)
	GetAllDevice(context.Context, *emptypb.Empty) (*DeviceList, error)
	// 网络唤醒
	SetDeviceMac(context.Context, *Device) (*emptypb.Empty, error)
	WakeOnLAN(context.Context, *Device) (*emptypb.Empty, error)
	// TCP
	CreateOneTCP(context.Context, *PortConfig) (*PortConfig, error)
	DeleteOneTCP(context.Context, *PortConfig) (*emptypb.Empty, error)
	GetOneTCP(context.Context, *PortConfig) (*PortConfig, error)
	GetAllTCP(context.Context, *Device) (*PortList, error)
	// UDP
	CreateOneUDP(context.Context, *PortConfig) (*PortConfig, error)
	DeleteOneUDP(context.Context, *PortConfig) (*emptypb.Empty, error)
	GetOneUDP(context.Context, *PortConfig) (*PortConfig, error)
	GetAllUDP(context.Context, *Device) (*PortList, error)
	// FTP
	CreateOneFTP(context.Context, *PortConfig) (*PortConfig, error)
	DeleteOneFTP(context.Context, *PortConfig) (*emptypb.Empty, error)
	GetOneFTP(context.Context, *PortConfig) (*PortConfig, error)
	GetAllFTP(context.Context, *Device) (*PortList, error)
	mustEmbedUnimplementedCommonDeviceManagerServer()
}

// UnimplementedCommonDeviceManagerServer must be embedded to have
// forward compatible implementations.
//
// NOTE: this should be embedded by value instead of pointer to avoid a nil
// pointer dereference when methods are called.
type UnimplementedCommonDeviceManagerServer struct{}

func (UnimplementedCommonDeviceManagerServer) AddDevice(context.Context, *Device) (*emptypb.Empty, error) {
	return nil, status.Errorf(codes.Unimplemented, "method AddDevice not implemented")
}
func (UnimplementedCommonDeviceManagerServer) DelDevice(context.Context, *Device) (*emptypb.Empty, error) {
	return nil, status.Errorf(codes.Unimplemented, "method DelDevice not implemented")
}
func (UnimplementedCommonDeviceManagerServer) GetAllDevice(context.Context, *emptypb.Empty) (*DeviceList, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetAllDevice not implemented")
}
func (UnimplementedCommonDeviceManagerServer) SetDeviceMac(context.Context, *Device) (*emptypb.Empty, error) {
	return nil, status.Errorf(codes.Unimplemented, "method SetDeviceMac not implemented")
}
func (UnimplementedCommonDeviceManagerServer) WakeOnLAN(context.Context, *Device) (*emptypb.Empty, error) {
	return nil, status.Errorf(codes.Unimplemented, "method WakeOnLAN not implemented")
}
func (UnimplementedCommonDeviceManagerServer) CreateOneTCP(context.Context, *PortConfig) (*PortConfig, error) {
	return nil, status.Errorf(codes.Unimplemented, "method CreateOneTCP not implemented")
}
func (UnimplementedCommonDeviceManagerServer) DeleteOneTCP(context.Context, *PortConfig) (*emptypb.Empty, error) {
	return nil, status.Errorf(codes.Unimplemented, "method DeleteOneTCP not implemented")
}
func (UnimplementedCommonDeviceManagerServer) GetOneTCP(context.Context, *PortConfig) (*PortConfig, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetOneTCP not implemented")
}
func (UnimplementedCommonDeviceManagerServer) GetAllTCP(context.Context, *Device) (*PortList, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetAllTCP not implemented")
}
func (UnimplementedCommonDeviceManagerServer) CreateOneUDP(context.Context, *PortConfig) (*PortConfig, error) {
	return nil, status.Errorf(codes.Unimplemented, "method CreateOneUDP not implemented")
}
func (UnimplementedCommonDeviceManagerServer) DeleteOneUDP(context.Context, *PortConfig) (*emptypb.Empty, error) {
	return nil, status.Errorf(codes.Unimplemented, "method DeleteOneUDP not implemented")
}
func (UnimplementedCommonDeviceManagerServer) GetOneUDP(context.Context, *PortConfig) (*PortConfig, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetOneUDP not implemented")
}
func (UnimplementedCommonDeviceManagerServer) GetAllUDP(context.Context, *Device) (*PortList, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetAllUDP not implemented")
}
func (UnimplementedCommonDeviceManagerServer) CreateOneFTP(context.Context, *PortConfig) (*PortConfig, error) {
	return nil, status.Errorf(codes.Unimplemented, "method CreateOneFTP not implemented")
}
func (UnimplementedCommonDeviceManagerServer) DeleteOneFTP(context.Context, *PortConfig) (*emptypb.Empty, error) {
	return nil, status.Errorf(codes.Unimplemented, "method DeleteOneFTP not implemented")
}
func (UnimplementedCommonDeviceManagerServer) GetOneFTP(context.Context, *PortConfig) (*PortConfig, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetOneFTP not implemented")
}
func (UnimplementedCommonDeviceManagerServer) GetAllFTP(context.Context, *Device) (*PortList, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetAllFTP not implemented")
}
func (UnimplementedCommonDeviceManagerServer) mustEmbedUnimplementedCommonDeviceManagerServer() {}
func (UnimplementedCommonDeviceManagerServer) testEmbeddedByValue()                             {}

// UnsafeCommonDeviceManagerServer may be embedded to opt out of forward compatibility for this service.
// Use of this interface is not recommended, as added methods to CommonDeviceManagerServer will
// result in compilation errors.
type UnsafeCommonDeviceManagerServer interface {
	mustEmbedUnimplementedCommonDeviceManagerServer()
}

func RegisterCommonDeviceManagerServer(s grpc.ServiceRegistrar, srv CommonDeviceManagerServer) {
	// If the following call pancis, it indicates UnimplementedCommonDeviceManagerServer was
	// embedded by pointer and is nil.  This will cause panics if an
	// unimplemented method is ever invoked, so we test this at initialization
	// time to prevent it from happening at runtime later due to I/O.
	if t, ok := srv.(interface{ testEmbeddedByValue() }); ok {
		t.testEmbeddedByValue()
	}
	s.RegisterService(&CommonDeviceManager_ServiceDesc, srv)
}

func _CommonDeviceManager_AddDevice_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(Device)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(CommonDeviceManagerServer).AddDevice(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: CommonDeviceManager_AddDevice_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(CommonDeviceManagerServer).AddDevice(ctx, req.(*Device))
	}
	return interceptor(ctx, in, info, handler)
}

func _CommonDeviceManager_DelDevice_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(Device)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(CommonDeviceManagerServer).DelDevice(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: CommonDeviceManager_DelDevice_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(CommonDeviceManagerServer).DelDevice(ctx, req.(*Device))
	}
	return interceptor(ctx, in, info, handler)
}

func _CommonDeviceManager_GetAllDevice_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(emptypb.Empty)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(CommonDeviceManagerServer).GetAllDevice(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: CommonDeviceManager_GetAllDevice_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(CommonDeviceManagerServer).GetAllDevice(ctx, req.(*emptypb.Empty))
	}
	return interceptor(ctx, in, info, handler)
}

func _CommonDeviceManager_SetDeviceMac_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(Device)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(CommonDeviceManagerServer).SetDeviceMac(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: CommonDeviceManager_SetDeviceMac_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(CommonDeviceManagerServer).SetDeviceMac(ctx, req.(*Device))
	}
	return interceptor(ctx, in, info, handler)
}

func _CommonDeviceManager_WakeOnLAN_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(Device)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(CommonDeviceManagerServer).WakeOnLAN(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: CommonDeviceManager_WakeOnLAN_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(CommonDeviceManagerServer).WakeOnLAN(ctx, req.(*Device))
	}
	return interceptor(ctx, in, info, handler)
}

func _CommonDeviceManager_CreateOneTCP_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(PortConfig)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(CommonDeviceManagerServer).CreateOneTCP(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: CommonDeviceManager_CreateOneTCP_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(CommonDeviceManagerServer).CreateOneTCP(ctx, req.(*PortConfig))
	}
	return interceptor(ctx, in, info, handler)
}

func _CommonDeviceManager_DeleteOneTCP_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(PortConfig)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(CommonDeviceManagerServer).DeleteOneTCP(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: CommonDeviceManager_DeleteOneTCP_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(CommonDeviceManagerServer).DeleteOneTCP(ctx, req.(*PortConfig))
	}
	return interceptor(ctx, in, info, handler)
}

func _CommonDeviceManager_GetOneTCP_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(PortConfig)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(CommonDeviceManagerServer).GetOneTCP(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: CommonDeviceManager_GetOneTCP_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(CommonDeviceManagerServer).GetOneTCP(ctx, req.(*PortConfig))
	}
	return interceptor(ctx, in, info, handler)
}

func _CommonDeviceManager_GetAllTCP_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(Device)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(CommonDeviceManagerServer).GetAllTCP(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: CommonDeviceManager_GetAllTCP_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(CommonDeviceManagerServer).GetAllTCP(ctx, req.(*Device))
	}
	return interceptor(ctx, in, info, handler)
}

func _CommonDeviceManager_CreateOneUDP_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(PortConfig)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(CommonDeviceManagerServer).CreateOneUDP(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: CommonDeviceManager_CreateOneUDP_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(CommonDeviceManagerServer).CreateOneUDP(ctx, req.(*PortConfig))
	}
	return interceptor(ctx, in, info, handler)
}

func _CommonDeviceManager_DeleteOneUDP_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(PortConfig)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(CommonDeviceManagerServer).DeleteOneUDP(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: CommonDeviceManager_DeleteOneUDP_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(CommonDeviceManagerServer).DeleteOneUDP(ctx, req.(*PortConfig))
	}
	return interceptor(ctx, in, info, handler)
}

func _CommonDeviceManager_GetOneUDP_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(PortConfig)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(CommonDeviceManagerServer).GetOneUDP(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: CommonDeviceManager_GetOneUDP_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(CommonDeviceManagerServer).GetOneUDP(ctx, req.(*PortConfig))
	}
	return interceptor(ctx, in, info, handler)
}

func _CommonDeviceManager_GetAllUDP_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(Device)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(CommonDeviceManagerServer).GetAllUDP(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: CommonDeviceManager_GetAllUDP_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(CommonDeviceManagerServer).GetAllUDP(ctx, req.(*Device))
	}
	return interceptor(ctx, in, info, handler)
}

func _CommonDeviceManager_CreateOneFTP_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(PortConfig)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(CommonDeviceManagerServer).CreateOneFTP(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: CommonDeviceManager_CreateOneFTP_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(CommonDeviceManagerServer).CreateOneFTP(ctx, req.(*PortConfig))
	}
	return interceptor(ctx, in, info, handler)
}

func _CommonDeviceManager_DeleteOneFTP_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(PortConfig)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(CommonDeviceManagerServer).DeleteOneFTP(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: CommonDeviceManager_DeleteOneFTP_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(CommonDeviceManagerServer).DeleteOneFTP(ctx, req.(*PortConfig))
	}
	return interceptor(ctx, in, info, handler)
}

func _CommonDeviceManager_GetOneFTP_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(PortConfig)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(CommonDeviceManagerServer).GetOneFTP(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: CommonDeviceManager_GetOneFTP_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(CommonDeviceManagerServer).GetOneFTP(ctx, req.(*PortConfig))
	}
	return interceptor(ctx, in, info, handler)
}

func _CommonDeviceManager_GetAllFTP_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(Device)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(CommonDeviceManagerServer).GetAllFTP(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: CommonDeviceManager_GetAllFTP_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(CommonDeviceManagerServer).GetAllFTP(ctx, req.(*Device))
	}
	return interceptor(ctx, in, info, handler)
}

// CommonDeviceManager_ServiceDesc is the grpc.ServiceDesc for CommonDeviceManager service.
// It's only intended for direct use with grpc.RegisterService,
// and not to be introspected or modified (even as a copy)
var CommonDeviceManager_ServiceDesc = grpc.ServiceDesc{
	ServiceName: "pb.CommonDeviceManager",
	HandlerType: (*CommonDeviceManagerServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "AddDevice",
			Handler:    _CommonDeviceManager_AddDevice_Handler,
		},
		{
			MethodName: "DelDevice",
			Handler:    _CommonDeviceManager_DelDevice_Handler,
		},
		{
			MethodName: "GetAllDevice",
			Handler:    _CommonDeviceManager_GetAllDevice_Handler,
		},
		{
			MethodName: "SetDeviceMac",
			Handler:    _CommonDeviceManager_SetDeviceMac_Handler,
		},
		{
			MethodName: "WakeOnLAN",
			Handler:    _CommonDeviceManager_WakeOnLAN_Handler,
		},
		{
			MethodName: "CreateOneTCP",
			Handler:    _CommonDeviceManager_CreateOneTCP_Handler,
		},
		{
			MethodName: "DeleteOneTCP",
			Handler:    _CommonDeviceManager_DeleteOneTCP_Handler,
		},
		{
			MethodName: "GetOneTCP",
			Handler:    _CommonDeviceManager_GetOneTCP_Handler,
		},
		{
			MethodName: "GetAllTCP",
			Handler:    _CommonDeviceManager_GetAllTCP_Handler,
		},
		{
			MethodName: "CreateOneUDP",
			Handler:    _CommonDeviceManager_CreateOneUDP_Handler,
		},
		{
			MethodName: "DeleteOneUDP",
			Handler:    _CommonDeviceManager_DeleteOneUDP_Handler,
		},
		{
			MethodName: "GetOneUDP",
			Handler:    _CommonDeviceManager_GetOneUDP_Handler,
		},
		{
			MethodName: "GetAllUDP",
			Handler:    _CommonDeviceManager_GetAllUDP_Handler,
		},
		{
			MethodName: "CreateOneFTP",
			Handler:    _CommonDeviceManager_CreateOneFTP_Handler,
		},
		{
			MethodName: "DeleteOneFTP",
			Handler:    _CommonDeviceManager_DeleteOneFTP_Handler,
		},
		{
			MethodName: "GetOneFTP",
			Handler:    _CommonDeviceManager_GetOneFTP_Handler,
		},
		{
			MethodName: "GetAllFTP",
			Handler:    _CommonDeviceManager_GetAllFTP_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "proto/mobile/mobile.proto",
}

const (
	Utils_Ping_FullMethodName                     = "/pb.Utils/Ping"
	Utils_SyncConfigWithToken_FullMethodName      = "/pb.Utils/SyncConfigWithToken"
	Utils_SyncConfigWithJsonConfig_FullMethodName = "/pb.Utils/SyncConfigWithJsonConfig"
	Utils_GetAllConfig_FullMethodName             = "/pb.Utils/GetAllConfig"
	Utils_LoadAllConfig_FullMethodName            = "/pb.Utils/LoadAllConfig"
	Utils_GetAllmDNSServiceList_FullMethodName    = "/pb.Utils/GetAllmDNSServiceList"
	Utils_GetmDNSServiceListByType_FullMethodName = "/pb.Utils/GetmDNSServiceListByType"
	Utils_ConvertOctonaryUtf8_FullMethodName      = "/pb.Utils/ConvertOctonaryUtf8"
	Utils_GetTokenModel_FullMethodName            = "/pb.Utils/GetTokenModel"
)

// UtilsClient is the client API for Utils service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://pkg.go.dev/google.golang.org/grpc/?tab=doc#ClientConn.NewStream.
type UtilsClient interface {
	Ping(ctx context.Context, in *emptypb.Empty, opts ...grpc.CallOption) (*emptypb.Empty, error)
	// 让后台服务登录服务器并同步配置
	SyncConfigWithToken(ctx context.Context, in *IoTManagerServerAndToken, opts ...grpc.CallOption) (*OpenIoTHubOperationResponse, error)
	SyncConfigWithJsonConfig(ctx context.Context, in *wrapperspb.StringValue, opts ...grpc.CallOption) (*OpenIoTHubOperationResponse, error)
	GetAllConfig(ctx context.Context, in *emptypb.Empty, opts ...grpc.CallOption) (*wrapperspb.StringValue, error)
	LoadAllConfig(ctx context.Context, in *wrapperspb.StringValue, opts ...grpc.CallOption) (*emptypb.Empty, error)
	GetAllmDNSServiceList(ctx context.Context, in *emptypb.Empty, opts ...grpc.CallOption) (*MDNSServiceList, error)
	GetmDNSServiceListByType(ctx context.Context, in *wrapperspb.StringValue, opts ...grpc.CallOption) (*MDNSServiceList, error)
	ConvertOctonaryUtf8(ctx context.Context, in *wrapperspb.StringValue, opts ...grpc.CallOption) (*wrapperspb.StringValue, error)
	GetTokenModel(ctx context.Context, in *wrapperspb.StringValue, opts ...grpc.CallOption) (*TokenModel, error)
}

type utilsClient struct {
	cc grpc.ClientConnInterface
}

func NewUtilsClient(cc grpc.ClientConnInterface) UtilsClient {
	return &utilsClient{cc}
}

func (c *utilsClient) Ping(ctx context.Context, in *emptypb.Empty, opts ...grpc.CallOption) (*emptypb.Empty, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(emptypb.Empty)
	err := c.cc.Invoke(ctx, Utils_Ping_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *utilsClient) SyncConfigWithToken(ctx context.Context, in *IoTManagerServerAndToken, opts ...grpc.CallOption) (*OpenIoTHubOperationResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(OpenIoTHubOperationResponse)
	err := c.cc.Invoke(ctx, Utils_SyncConfigWithToken_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *utilsClient) SyncConfigWithJsonConfig(ctx context.Context, in *wrapperspb.StringValue, opts ...grpc.CallOption) (*OpenIoTHubOperationResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(OpenIoTHubOperationResponse)
	err := c.cc.Invoke(ctx, Utils_SyncConfigWithJsonConfig_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *utilsClient) GetAllConfig(ctx context.Context, in *emptypb.Empty, opts ...grpc.CallOption) (*wrapperspb.StringValue, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(wrapperspb.StringValue)
	err := c.cc.Invoke(ctx, Utils_GetAllConfig_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *utilsClient) LoadAllConfig(ctx context.Context, in *wrapperspb.StringValue, opts ...grpc.CallOption) (*emptypb.Empty, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(emptypb.Empty)
	err := c.cc.Invoke(ctx, Utils_LoadAllConfig_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *utilsClient) GetAllmDNSServiceList(ctx context.Context, in *emptypb.Empty, opts ...grpc.CallOption) (*MDNSServiceList, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(MDNSServiceList)
	err := c.cc.Invoke(ctx, Utils_GetAllmDNSServiceList_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *utilsClient) GetmDNSServiceListByType(ctx context.Context, in *wrapperspb.StringValue, opts ...grpc.CallOption) (*MDNSServiceList, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(MDNSServiceList)
	err := c.cc.Invoke(ctx, Utils_GetmDNSServiceListByType_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *utilsClient) ConvertOctonaryUtf8(ctx context.Context, in *wrapperspb.StringValue, opts ...grpc.CallOption) (*wrapperspb.StringValue, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(wrapperspb.StringValue)
	err := c.cc.Invoke(ctx, Utils_ConvertOctonaryUtf8_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *utilsClient) GetTokenModel(ctx context.Context, in *wrapperspb.StringValue, opts ...grpc.CallOption) (*TokenModel, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(TokenModel)
	err := c.cc.Invoke(ctx, Utils_GetTokenModel_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// UtilsServer is the server API for Utils service.
// All implementations must embed UnimplementedUtilsServer
// for forward compatibility.
type UtilsServer interface {
	Ping(context.Context, *emptypb.Empty) (*emptypb.Empty, error)
	// 让后台服务登录服务器并同步配置
	SyncConfigWithToken(context.Context, *IoTManagerServerAndToken) (*OpenIoTHubOperationResponse, error)
	SyncConfigWithJsonConfig(context.Context, *wrapperspb.StringValue) (*OpenIoTHubOperationResponse, error)
	GetAllConfig(context.Context, *emptypb.Empty) (*wrapperspb.StringValue, error)
	LoadAllConfig(context.Context, *wrapperspb.StringValue) (*emptypb.Empty, error)
	GetAllmDNSServiceList(context.Context, *emptypb.Empty) (*MDNSServiceList, error)
	GetmDNSServiceListByType(context.Context, *wrapperspb.StringValue) (*MDNSServiceList, error)
	ConvertOctonaryUtf8(context.Context, *wrapperspb.StringValue) (*wrapperspb.StringValue, error)
	GetTokenModel(context.Context, *wrapperspb.StringValue) (*TokenModel, error)
	mustEmbedUnimplementedUtilsServer()
}

// UnimplementedUtilsServer must be embedded to have
// forward compatible implementations.
//
// NOTE: this should be embedded by value instead of pointer to avoid a nil
// pointer dereference when methods are called.
type UnimplementedUtilsServer struct{}

func (UnimplementedUtilsServer) Ping(context.Context, *emptypb.Empty) (*emptypb.Empty, error) {
	return nil, status.Errorf(codes.Unimplemented, "method Ping not implemented")
}
func (UnimplementedUtilsServer) SyncConfigWithToken(context.Context, *IoTManagerServerAndToken) (*OpenIoTHubOperationResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method SyncConfigWithToken not implemented")
}
func (UnimplementedUtilsServer) SyncConfigWithJsonConfig(context.Context, *wrapperspb.StringValue) (*OpenIoTHubOperationResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method SyncConfigWithJsonConfig not implemented")
}
func (UnimplementedUtilsServer) GetAllConfig(context.Context, *emptypb.Empty) (*wrapperspb.StringValue, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetAllConfig not implemented")
}
func (UnimplementedUtilsServer) LoadAllConfig(context.Context, *wrapperspb.StringValue) (*emptypb.Empty, error) {
	return nil, status.Errorf(codes.Unimplemented, "method LoadAllConfig not implemented")
}
func (UnimplementedUtilsServer) GetAllmDNSServiceList(context.Context, *emptypb.Empty) (*MDNSServiceList, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetAllmDNSServiceList not implemented")
}
func (UnimplementedUtilsServer) GetmDNSServiceListByType(context.Context, *wrapperspb.StringValue) (*MDNSServiceList, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetmDNSServiceListByType not implemented")
}
func (UnimplementedUtilsServer) ConvertOctonaryUtf8(context.Context, *wrapperspb.StringValue) (*wrapperspb.StringValue, error) {
	return nil, status.Errorf(codes.Unimplemented, "method ConvertOctonaryUtf8 not implemented")
}
func (UnimplementedUtilsServer) GetTokenModel(context.Context, *wrapperspb.StringValue) (*TokenModel, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetTokenModel not implemented")
}
func (UnimplementedUtilsServer) mustEmbedUnimplementedUtilsServer() {}
func (UnimplementedUtilsServer) testEmbeddedByValue()               {}

// UnsafeUtilsServer may be embedded to opt out of forward compatibility for this service.
// Use of this interface is not recommended, as added methods to UtilsServer will
// result in compilation errors.
type UnsafeUtilsServer interface {
	mustEmbedUnimplementedUtilsServer()
}

func RegisterUtilsServer(s grpc.ServiceRegistrar, srv UtilsServer) {
	// If the following call pancis, it indicates UnimplementedUtilsServer was
	// embedded by pointer and is nil.  This will cause panics if an
	// unimplemented method is ever invoked, so we test this at initialization
	// time to prevent it from happening at runtime later due to I/O.
	if t, ok := srv.(interface{ testEmbeddedByValue() }); ok {
		t.testEmbeddedByValue()
	}
	s.RegisterService(&Utils_ServiceDesc, srv)
}

func _Utils_Ping_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(emptypb.Empty)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(UtilsServer).Ping(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Utils_Ping_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(UtilsServer).Ping(ctx, req.(*emptypb.Empty))
	}
	return interceptor(ctx, in, info, handler)
}

func _Utils_SyncConfigWithToken_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(IoTManagerServerAndToken)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(UtilsServer).SyncConfigWithToken(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Utils_SyncConfigWithToken_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(UtilsServer).SyncConfigWithToken(ctx, req.(*IoTManagerServerAndToken))
	}
	return interceptor(ctx, in, info, handler)
}

func _Utils_SyncConfigWithJsonConfig_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(wrapperspb.StringValue)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(UtilsServer).SyncConfigWithJsonConfig(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Utils_SyncConfigWithJsonConfig_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(UtilsServer).SyncConfigWithJsonConfig(ctx, req.(*wrapperspb.StringValue))
	}
	return interceptor(ctx, in, info, handler)
}

func _Utils_GetAllConfig_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(emptypb.Empty)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(UtilsServer).GetAllConfig(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Utils_GetAllConfig_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(UtilsServer).GetAllConfig(ctx, req.(*emptypb.Empty))
	}
	return interceptor(ctx, in, info, handler)
}

func _Utils_LoadAllConfig_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(wrapperspb.StringValue)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(UtilsServer).LoadAllConfig(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Utils_LoadAllConfig_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(UtilsServer).LoadAllConfig(ctx, req.(*wrapperspb.StringValue))
	}
	return interceptor(ctx, in, info, handler)
}

func _Utils_GetAllmDNSServiceList_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(emptypb.Empty)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(UtilsServer).GetAllmDNSServiceList(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Utils_GetAllmDNSServiceList_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(UtilsServer).GetAllmDNSServiceList(ctx, req.(*emptypb.Empty))
	}
	return interceptor(ctx, in, info, handler)
}

func _Utils_GetmDNSServiceListByType_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(wrapperspb.StringValue)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(UtilsServer).GetmDNSServiceListByType(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Utils_GetmDNSServiceListByType_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(UtilsServer).GetmDNSServiceListByType(ctx, req.(*wrapperspb.StringValue))
	}
	return interceptor(ctx, in, info, handler)
}

func _Utils_ConvertOctonaryUtf8_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(wrapperspb.StringValue)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(UtilsServer).ConvertOctonaryUtf8(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Utils_ConvertOctonaryUtf8_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(UtilsServer).ConvertOctonaryUtf8(ctx, req.(*wrapperspb.StringValue))
	}
	return interceptor(ctx, in, info, handler)
}

func _Utils_GetTokenModel_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(wrapperspb.StringValue)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(UtilsServer).GetTokenModel(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Utils_GetTokenModel_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(UtilsServer).GetTokenModel(ctx, req.(*wrapperspb.StringValue))
	}
	return interceptor(ctx, in, info, handler)
}

// Utils_ServiceDesc is the grpc.ServiceDesc for Utils service.
// It's only intended for direct use with grpc.RegisterService,
// and not to be introspected or modified (even as a copy)
var Utils_ServiceDesc = grpc.ServiceDesc{
	ServiceName: "pb.Utils",
	HandlerType: (*UtilsServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "Ping",
			Handler:    _Utils_Ping_Handler,
		},
		{
			MethodName: "SyncConfigWithToken",
			Handler:    _Utils_SyncConfigWithToken_Handler,
		},
		{
			MethodName: "SyncConfigWithJsonConfig",
			Handler:    _Utils_SyncConfigWithJsonConfig_Handler,
		},
		{
			MethodName: "GetAllConfig",
			Handler:    _Utils_GetAllConfig_Handler,
		},
		{
			MethodName: "LoadAllConfig",
			Handler:    _Utils_LoadAllConfig_Handler,
		},
		{
			MethodName: "GetAllmDNSServiceList",
			Handler:    _Utils_GetAllmDNSServiceList_Handler,
		},
		{
			MethodName: "GetmDNSServiceListByType",
			Handler:    _Utils_GetmDNSServiceListByType_Handler,
		},
		{
			MethodName: "ConvertOctonaryUtf8",
			Handler:    _Utils_ConvertOctonaryUtf8_Handler,
		},
		{
			MethodName: "GetTokenModel",
			Handler:    _Utils_GetTokenModel_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "proto/mobile/mobile.proto",
}
